(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{237:function(e,t,a){"use strict";a.r(t);var s=a(6),i=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"frequently-asked-questions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#frequently-asked-questions"}},[e._v("#")]),e._v(" Frequently asked questions")]),e._v(" "),a("p",[e._v("Questions that may arise before, at or after this point. so if you're wondering about one thing or another, here it is:")]),e._v(" "),a("h2",{attrs:{id:"is-webassembly-going-to-supersede-javascript"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-webassembly-going-to-supersede-javascript"}},[e._v("#")]),e._v(" Is WebAssembly going to supersede JavaScript?")]),e._v(" "),a("p",[e._v('No, and it is not meant to do so. There are use cases one can handle "better" than the other, with "better" depending on the use case. This can be making an algorithm performing with less overhead on the one hand or getting an UI job done quicker on the other. As always, picking the right tool for the job is key, and AssemblyScript just so happens to blur the line a bit.')]),e._v(" "),a("h2",{attrs:{id:"is-webassembly-always-faster"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-webassembly-always-faster"}},[e._v("#")]),e._v(" Is WebAssembly "),a("em",[e._v("always")]),e._v(" faster?")]),e._v(" "),a("p",[e._v("No, not always. But it can be. The execution characteristics of ahead-of-time compiled WebAssembly differ from just-in-time compiled JavaScript in that it is "),a("em",[e._v("more predictable")]),e._v(" in a way that enables a WebAssembly program to remain on a reasonably fast path over the entire course of execution, while a JavaScript VM tries hard to do all sorts of smart optimizations before and "),a("em",[e._v("while")]),e._v(" the code is executing. This implies that a JavaScript VM can make both very smart decisions, especially for well-written code with a clear intent, but might also have to reconsider its strategy to do something more general if its assumptions did not hold. If you are primarily interested in performance, our rule of thumb (that is: from an AssemblyScript perspective) is:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[e._v("Scenario")]),e._v(" "),a("th",{staticStyle:{"text-align":"left"}},[e._v("Recommendation")])])]),e._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("Compute-heavy algorithm")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("Use WebAssembly")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("Mostly interacts with the DOM")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("Mostly use JavaScript")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("Games")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("Use WebAssembly for CPU-intensive parts")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("WebGL")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("Depends how much of it is calling APIs. Probably both.")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("Websites, Blogs, ...")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("JavaScript is your friend")])])])]),e._v(" "),a("p",[e._v("Or: WebAssembly is great for computational tasks, stuff with numbers, but still needs some time to become more convenient and efficient "),a("em",[e._v("at the same time")]),e._v(" where sharing numbers between the module and the host isn't enough.")]),e._v(" "),a("p",[e._v("Bonus: If you are considering another language than AssemblyScript, pick one that doesn't (currently) compile an interpreter to WebAssembly to run your code, because that's neither small nor fast.")]),e._v(" "),a("p",[e._v("Bonus: At this point in time, when a tool does WebAssemblyâ‡„JavaScript bindings for you, appreciate its convenience, but also take care of what it actually does. For example, what looks like just passing a function argument might involve allocating/copying memory with implicit conversions like re-encoding a string.")]),e._v(" "),a("h2",{attrs:{id:"is-assemblyscript-always-faster"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-assemblyscript-always-faster"}},[e._v("#")]),e._v(" Is AssemblyScript "),a("em",[e._v("always")]),e._v(" faster?")]),e._v(" "),a("p",[e._v("No, not always. But there are use cases especially well-suited for it, like creating a Game Boy emulator by making use of its low-level capabilities, essentially emitting raw WebAssembly using a nicer syntax. But ordinary code doesn't magically become faster just by compiling to WebAssembly, especially when making extensive use of managed objects that require memory management and garbage collection (this has its cost in every language) or talking to the host in structures that WebAssembly isn't currently good at, like strings or more complex objects. Low-level code (just functions, numbers, math and hard work) is always the best choice when all you care about is raw performance.")]),e._v(" "),a("h2",{attrs:{id:"how-does-assemblyscript-compare-relate-to-c-rust"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#how-does-assemblyscript-compare-relate-to-c-rust"}},[e._v("#")]),e._v(" How does AssemblyScript compare/relate to C++/Rust?")]),e._v(" "),a("p",[e._v("First and foremost: Both Emscripten (C++) and Rust have very mature tooling to compile to WebAssembly and are made by the smartest people on this field. Also, both can make use of compiler infrastructure that has been created by many individuals and corporations over years. In contrast, AssemblyScript is a relatively young project with limited resources that strives to create a viable alternative from another perspective.")]),e._v(" "),a("p",[e._v("More precisely: AssemblyScript is putting anything web - from APIs to syntax to WebAssembly - first and "),a("em",[e._v("then")]),e._v(" glues it all together, while others lift an existing ecosystem to the web. Fortunately, there is Binaryen, a compiler infrastructure and toolchain library for WebAssembly primarily created by the main author of Emscripten, that we can utilize to considerably close the gap, and we are very thankful for that. It's not as optimal for AssemblyScript-generated code as it is for LLVM-generated code in a few cases, but it's already pretty good and continuously becoming better. It's also noteworthy that AssemblyScript is still behind in specific language features, but we are working on that.")]),e._v(" "),a("p",[e._v("In short: AssemblyScript differs in that it is new and tries another approach. It's not as mature as Emscripten and Rust, but there is something about the idea that is definitely appealing. If you find it appealing as well, AssemblyScript is for you.")])])}),[],!1,null,null,null);t.default=i.exports}}]);